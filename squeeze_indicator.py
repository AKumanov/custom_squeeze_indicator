import numpy as np  
import helper as helper_func
import bollinger_bands
import keltner_channel
import simple_indicators
import matplotlib.pyplot as plt

def squeeze(data, boll_lookback, boll_vol, kelt_lookback, kelt_vol, close, where):
    
    # adding columns
    data = helper_func.adder(data, 20)
    
    # adding bollinger bands
    data = bollinger_bands.bollinger_bands(data, boll_lookback, boll_vol, close, where)

    # adding keltner channel
    data = keltner_channel.keltner_channel(data, kelt_lookback, kelt_lookback, kelt_vol, close, where + 2)

    # Donchian Middle Point
    """
    Donchian channels are three lines generated by MA calculations that comprise an indicator formed by
    upper and lower bands around a midrange or median band. The upper band marks the highest price of a security
    over N periods while the lower bands marks the lowest price of a security over N periods. The area
    between the upper and lower bands represents the Dochian Channel.
    """
    for i in range(len(data)):
        try:
            data[i, where + 4] = max(data[i - boll_lookback + 1:i + 1, 1])
        except ValueError:
            pass
    
    for i in range(len(data)):
        try:
            data[i, where + 5] = min(data[i - boll_lookback + 1:i + 1, 2])
        except ValueError:
            pass
    data[:, where + 6] = (data[:, where + 4] + data[:, where + 5]) / 2
    data = helper_func.deleter(data, where + 4, 2)

    # Calculating Simple Moving Average on the Market
    data = simple_indicators.ma(data, boll_lookback, close, where + 5)

    # Calculating Delta
    for i in range(len(data)):
        data[i, where + 6] = data[i, close] - ((data[i, where + 4] + data[i, where + 5]) / 2)
    
    # Final Smoothing
    data = simple_indicators.ma(data, boll_lookback, where + 6, where + 7)

    # Cleaning
    data = helper_func.deleter(data, where + 4, 3)

    # Squeeze Detection
    for i in range(len(data)):
        if data[i, where] < data[i, where + 2] and data[i, where + 1] > data[i, where + 3]:
            data[i, where + 5] = 0.001
    
    return data


def indicator_plot_squeeze(data, my_data, window=250):
    fig, ax = plt.subplots(2, figsize = (10, 5))
    Chosen = data[-window:, ]
    
    for i in range(len(Chosen)):
        
        ax[0].vlines(x = i, ymin = Chosen[i, 2], ymax = Chosen[i, 1], color = 'black', linewidth = 1)  
   
    ax[0].grid() 
    
    ax[0].plot(my_data[-window:, 4], color = 'blue')   
    ax[0].plot(my_data[-window:, 5], color = 'blue') 
    ax[0].plot(my_data[-window:, 6], color = 'pink') 
    ax[0].plot(my_data[-window:, 7], color = 'pink')
    for i in range(len(Chosen)):
        
        if Chosen[i, 8] > 0:
            ax[1].vlines(x = i, ymin = 0, ymax = Chosen[i, 8], color = 'black', linewidth = 1)  
        
        if Chosen[i, 8] < 0:
            ax[1].vlines(x = i, ymin = Chosen[i, 8], ymax = 0, color = 'black', linewidth = 1)
        if Chosen[i, 8] == 0:
            ax[1].vlines(x = i, ymin = Chosen[i, 8], ymax = 0, color = 'black', linewidth = 1)  
            
    ax[1].grid() 
    ax[1].axhline(y = 0, color = 'black', linewidth = 1.0, linestyle = '--')
    for i in range(len(Chosen)):
        
        if Chosen[i, 9] == 0.001:
            
            x = i
            y = Chosen[i, 8] + (-Chosen[i, 8])
        
            ax[1].annotate(' ', xy = (x, y), arrowprops = dict(width = 5, headlength = 3, headwidth = 3, facecolor = 'red', color='red'))
        
        elif Chosen[i, 9] == 0:
            
            x = i
            y = Chosen[i, 8] + (-Chosen[i, 8])
        
            ax[1].annotate(' ', xy = (x, y), arrowprops = dict(width = 5, headlength = 3, headwidth = 3, facecolor = 'green', color='green'))
    plt.show()


def singal(data):
    for i in range(len(data)):

        # Bullish Signal
        if data[i, 9] != 0.001 and data[i - 1, 9] == 0.001 and data[i, 8] > 0:
            data[i, 10] = 1
        
        # Bearish Signal
        elif data[i, 9] != 0.001 and data[i -1, 9] == 0.001 and data[i, 8] < 0:
            data[i, 11] = -1